## 预习
1. 为什么引入继承的功能，继承用来帮我们解决什么问题
2. 类继承另一个类之后
    1. 构造方法是否被继承
    2. 实例方法和成员(非静态)是否被继承
    3. 访问权限修饰符是否对子类继承到的方法和成员产生影响
    4. 是否能够继承静态的方法和成员
3. 是否可以多继承，为什么不引入多继承
4. 是否可以继承自己
5. 继承后如果子类定义的方法名或成员名和父类一样会出现什么情况
6. 是否所有的java类都有父类
7. 是否可以防止一个类被继承

# 预备知识

* 类和对象基础

## 课程说明

* 继承是面向对象语言的另一大特性，主要介绍继承的概念和语法，之前介绍的访问权限修饰符中的protected约束了继承关系下的访问权限，这里结合继承进行介绍。之后间给介绍继承中子类的相关特性，例如方法的重写、如何防止子类重写方法等。最后介绍所有类的父类Object相关的内容。

## 学习目标

- 学会继承的语法，知道什么时候使用继承
- 学会合理的使用protected限制访问权限
- 了解并能够使用super关键字
- 了解Object类的相关

# 继承

类是具备相同数据属性和行为的对象的模板，处理实际问题的时候，很多类可能存在共通的成员和方法，这些可以成员和方法可以再进行抽象，变为一个更通用的模板（父类），其他的类（子类）只需要继承这个类，就具备相同的成员和方法。

比如我们之前定义过大象类，里面有身高属性，现在想要将冰箱里装狮子，那需要再定义一个狮子类，同样有身高属性，那这时候可以把身高向上抽象，因为狮子和大象都是动物，所以抽象成一个动物类具备身高，狮子和大象类继承动物类即可。那么动物类就是父类，狮子和大象类就是子类。

继承是所有OOP语言不可缺少的组成部分。使用继承可以减少代码重复，比较重要的一点是建立了类和类之间的父、子联系。子类 is-a 父类 即"大象类"是一个"动物类"

对于父类和子类有多种称呼，

父类（parent class）—— 孩子类（child class）
超类（super class）—— 子类（subclass）
基类（base class）—— 派生类（derived class）

这里统一使用父类和子类

## 实现继承

java中继承只允许单继承，每个子类只允许有一个父类，不允许同时继承多个类。是为了避免引入多继承后的一系列复杂的情况。比如菱形继承。 ![image](http://note.youdao.com/yws/res/9221/B664EEADEF6E4AFB8E44AF01E03D9F00?ynotemdtimestamp=1583646137801)

在子类定义中使用`extends`关键字标识需要继承的父类。继承后子类就具备了父类中定义的成员变量和方法。这些成员和方法可以通过子类对象来使用。

语法示例

```
class 子类 extends 父类{
    
}
```

代码示例

```
package club.banyuan;

public class Father {

  public String familyName = "诸葛";

  public String getFamilyFeature() {
    return "出师未捷身先死";
  }
}
package club.banyuan;

public class Son extends Father {

}
package club.banyuan;

public class Main {

  public static void main(String[] args) {
    Son son = new Son();

    // 通过子类对象访问父类中定义的成员
    System.out.println(son.familyName);

    // 通过子类对象访问父类中定义的方法
    System.out.println(son.getFamilyFeature());
  }
}
```

# 父类的访问修饰符

子类具备了父类中定义的所有成员和方法，但是子类中是否可以访问这些成员和方法，以及其他类中是否可以通过子类对象来访问这些成员和方法，要根据父类中对成员和方法的访问修饰符来决定

## protected

子类继承的父类`protected`方法和成员仅能在和父类同包的类中使用或子类内部使用。子类可以和父类同包也可以不同包。不同包的内部也可调用`protected`方法，但是其他类里面就不能用了

其他类使用`protected`方法的时候只看和父类是不是同包，如果是父类同包，那么子类就算不同包也可以使用

1. 子类和父类在同一个包下或不同包下，子类内部都可以访问到父类中`protected`的成员和方法
2. 子类和父类在同一个包下，其他类不在同一个包下，那么其他类中不能访问这些成员和方法
3. 子类和父类不再同一个包下，其他类如果和父类同包，则可以通过子类或父类对象访问`protected`成员和方法。如果其他类和父类不同包，即便和子类同包，也不能通过子类或父类独享访问这些成员和方法。

## private

1. 子类内部不能访问父类的私有成员和方法，其他类就更不可能访问到这些成员和方法
2. 如果父类的外部方法（public protected）访问其`private`属性或方法，子类可以通过调用这些方法间接访问这些`private`属性或方法

## default

1. 子类和父类在同一个包下，子类内部可以访问到父类默认权限的成员和方法，其他类如果也在同一个包下，则其他类可以通过子类或父类对象访问到这些成员和方法。
2. 子类和父类在同一个包下，其他类不在同一个包下，那么其他类中不能访问这些成员和方法
3. 子类和父类不再同一个包下，子类内部也访问不到默认权限的属性和方法，其他类无论在什么包下面，也不能通过子类来访问这些属性和方法

## 视频演示

继承中的访问修饰符

# 子类重写父类方法

子类中定义相同名称的父类方法叫做方法重写(override)

重写的规定

1. 子类不能重写父类的private方法
2. 重写的方法名和参数列表必须与父类中完全相同
3. 重写的方法的访问修饰符不小于父类被重写方法的访问修饰符
4. 返回值
   - 父类方法是void或基本数据类型，子类重写的方法必须和父类方法保持一致
   - 父类方法是类A的对象，那么子类重写的方法必须是类A的对象或类A子类的对象
5. 异常（后续介绍）
   - 父类方法不抛出异常，则子类重写的方法也不能抛出异常
   - 子类重写方法抛出的异常必须是父类方法抛出的异常类，或是其子类

## @Override

建议在子类重写的方法上增加Override注解，表示当前方法是重写父类的方法，用于编译器检查，编译器将检查是否父类具备这个被重写的方法，并且检查子类重写的方法声明是否满足重写原则

## 视频演示

方法重写

# super

在子类对象创建出来之后，会为父类中定义的所有成员变量分配内存空间。使用`super`来引用这块内存空间。子类对象中并不会真的有一个父类对象的引用，`super`只是提供用来获取子类中父类成员或方法存储区域的一种方式，并不是真的指代了一个父类对象，因此`super`是不能作为返回值返回的。

## 引用父类成员变量

如果子类定义了和父类相同名称的成员变量，则父类定义的变量在子类内部会被屏蔽，可以通过super获取

当子类得到父类的属性后，如果自己内部定义了相同名称的属性，也不会覆盖继承过来的父类属性，两个属性有各自的存储区域，如果想要在子类内部访问到父类的属性的话，可以使用`super`访问这个存储区（前提是这个父类属性开放了给子类的访问权限），但是在其他类中，就不能访问到子类继承过来的父类属性了，除非子类提供相应的方法

## 引用父类方法

重写的方法可以覆盖父类的方法实现，同样子类可以命名和父类同名的成员变量名来覆盖父类中定义的成员变量。但是在子类对象创建出来之后，还是为父类成员或覆盖了父类成员变量命名后如果想要调用父类的方法或成员变量时，则需要使用`super.`的方式调用父类存储区域的属性和方法，前提是子类具备该父类属性和方法访问权限

## 引用父类构造方法

在子类实例化的时候，先会创建父类的存储空间，会调用父类的构造方法。初始化这些存储空间。调用父类构造方法时，可以有两种选择，一种是在子类的构造方法中使用`super`指定父类构造方法，另一种是不指定，则默认调用父类无参的构造方法。如果父类没有提供默认的构造方法（在不写构造方法时，编译器会自动加入一个无参的构造方法，显示提供了构造方法后，编译器就不再做这个动作了，因此如果显示提供的构造方法中没有提供一个无参的构造方法，则子类实例化的时候需要手动指定调用父类的构造方法，使用super）

# 使用final阻止继承

使用`final`修饰类，则这个类不允许被继承

使用`final`修饰方法，可以确保父类的一些方法不会被子类修改行为

```
public final class A {
    
}
```

以下将编译报错，不允许继承final的类

```
public class B extends A {
    
}
```

使用`final`修饰方法，则这个方法不能被子类重写

```
public class A {
    public final void methodA() {
        
    }
}

// 编译报错，不允许重写methodA
public class B extends A {
    public void methodA() {
        
    }
}
```

# 继承树

继承并不仅限于一个层次，可以由一个公共父类逐层向下

![image](http://note.youdao.com/yws/res/9251/84B28FD73D6B46419C7E70858B301811?ynotemdtimestamp=1583646137801)

## 多级继承关系下的成员和方法

如果是 B类继承A类，C类继承B类，那么C类同时拥有A类和B类所有的方法和成员，在访问权限允许的情况下在C内部或通过C类对象直接使用，如果B类覆盖了A类的成员或方法，那么C类就无法获取到A类中成员和方法了，仅能访问到B类中覆盖后的成员值和方法。那么为什么不提供子类直接访问父类的父类的存储区域的方式，例如super.super 因为子类相当于父类的扩展，基于父类的封装，如果能够访问到父类上一级，将会破坏父类的封装性。

## Object

java.lang.Object是一个预定义的类。 Object类是所有java类的父类，如果声明了一个类，没有继承任何类，默认继承Object类。

因此所有的类都拥有了Object类中定义的方法

### native关键字

native关键字标识的Java方法为本地方法，本地方法和其它方法不一样，本地方法意味着和操作系统有关，这些方法需要调用针对当前操作系统编写的程序，因此使用了native的程序可移植性都不太高，不过java默认提供的native方法在每个操作系统对应的jvm中都有实现，因此调用java默认提供的native方法不会影响程序的跨平台特性。但是如果调用第三方定义的native方法，可能会导致某些操作系统下无法运行。

### 常用方法

#### getClass

```
public final native Class<?> getClass();
```

该方法由final声明本地方法，不能被重写，作用是返回运行时类对象，通过这个类对象可以获取该运行时类的相关成员和方法。通常用于反射，将在以后进行讲解。

#### hashCode

```public native int hashCode();```

这是一个由native声明的本地方法，作用是返回对象的哈希码（是int类型的数值）。hashCode方法返回的数值是为了配合数据结构保存数据或比较两个对象时使用。如果子类不重写该方法，则由jvm的底层默认实现生成hash值

#### equals

equals方法判断两个对象对象是否相等。方法定义如下：

```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

`==`用来判断两个对象的引用的内容是否相同，即比较两个对象引用指向的内存地址是否相同。当且仅当两个引用指向相同内存地址，返回值为true，否则将返回false。

如果子类需要比较两个子类对象并且不希望比较地址值，可以重写equals方法，自定义两个子类对象的比较方式。重写equals方法通常需要同时重写hashcode方法，满足以下规则

- 如果两个对象的equals值比较返回值为true，那么它们的hashcode值一定相等
- 如果两个对象的equals值比较返回值为false，那么他们的hashcode值可能相等，也可能不相等。
- 如果两个对象hashcode值相等，那么两个对象的equals值比较返回值可能为false，也可能为true
- 如果两个对象hashcode值不相等，那么两个对象的equals值比较返回值一定为false

#### toString

toString方法可以返回该对象的字符串表示。或者说将任何一个对象转换成字符串返回。方法定义如下：

```java
public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
```

子类可以重写此方法返回更有意义的字符串信息。