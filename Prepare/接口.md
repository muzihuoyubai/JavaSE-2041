##
1. 引入接口是为了解决什么问题
2. 接口为什么不能够被实例化
3. 接口中是否可以出现成员变量，如果是，成员变量修饰符有什么限制
4. 接口是否可以继承别的接口，是否可以多继承接口
5. 接口中的方法修饰符有什么限制
6. 接口中是否允许出现静态的成员变量或方法
7. 接口和抽象类有什么区别，什么场景使用接口，什么场景使用抽象类
8. 接口是否可以继承，是否允许多继承。
9. 接口是否有多态性


# 预备知识

* 类和对象基础
* 类的继承

## 课程说明

为了解决单继承的问题，需要引入接口的概念，首先介绍接口的概念，之后介绍如何定义和使用接口。还需要了解接口如何进行扩展，即接口的继承关系。最后通过比较接口和抽象类，加强对接口以及抽象类实际应用的理解

## 学习目标

- 学会定义和使用接口
- 了解什么时候定义接口什么时候定义抽象类

# 接口

单一继承只能有一个父类，在现实中这样的制约过于严格。例如大象、狮子、老虎都继承自动物类，大象类和狮子类可以被装进冰箱，而老虎类不能被装进冰箱。我们本可以定义一个能够被装进冰箱的类，然后让大象和狮子继承这个类，但是他们已经继承了动物类，而这个行为特征也不能放到动物类里面，因为一旦放进去，老虎也同时具备了这个行为。为了让他们能够同时具备动物和被装进冰箱的特征，java没有办法继承多个类，使用了接口解决这个问题。

继承包含两种含义，一种是“类中都使用了什么数据结构和算法”，即实现的继承。另一种是“类有哪些方法”，也就是说这个类都支持哪些操作，即规格的继承。

java对这两者有明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。

java允许用extends继承一个父类（实现的继承），所以类的继承是单一的。类的关系树和类库就相对简单，而implements可以指定多个接口（规格的集成），接口规定了要怎样处理该对象

接口对实现没有任何限制。也就是说，接口可以由跟实现的继承没有任何关系的类来实现。也就是说，实现这一接口的类可以继承任何其他的类。

接口分为两部分，一个是接口的声明,声明主要是描述有哪些功能（即方法声明），一个是接口的实现（即方法实现）。

## 接口声明

接口的声明不是定义在class内部，而是和定义class一样，定义一个接口源文件文件 接口的声明只定义规格的部分，即方法的声明。使用`interface`表示当前文件是一个接口，接口最后也会被编译成以接口名命名的class文件，注意前面的访问修饰符，和class一样可以使用public和不写，如果不写指代当前包下可用

接口中声明的所有的方法默认都是`public abstract`的

```
public interface Carryable {

  void lifted();
}
```

## 接口的实现

使用`implements` 加接口名的方式进行接口实现。叫做Elephant类实现了接口Carryable。一旦类实现了接口，就需要实现其方法的具体内容。如下，实现了`lifted`方法的具体内容，打印了字符串

```
public class Elephant implements Carryable {

  @Override
  public void lifted() {
    System.out.println("大象被举起");
  }
}
```

## 接口的使用

无法直接实例化接口，和抽象类类似。可以使用接口类型变量引用实例化的对象或者对象作为参数传入

接口变量可以引用不同的类的实例，只要他们都实现了这个接口即可，反过来说这些实现了接口的类都可以看做是接口的数据类型，同样可以使用instanceof 来判断变量的实际类型

## 接口中的成员

接口中定义的成员默认是`public static final`的，即接口中定义的成员都是常量，并且定义的变量必须被初始化。因为接口中没有构造方法。

## 接口中的方法

### 默认方法

有时候多个实现接口的类中，一些方法的实现基本相同，仅有部分需要实现类重写，java8中引入了接口方法的默认值，可以为接口方法提供一个默认实现。必须用`default`标记这样的方法。

### 静态方法

java8中，允许在接口中增加静态方法。在这之前，如果定义一个接口，想要先提供一些接口的工具类，那么需要新增一个class，编写方法。可以参考 `java.util.Collections/Collection`和`java.nio.file.Path/Paths`

# 接口的继承

## 接口的多继承

接口也可以使用`extends`继承其他的接口，并且可以继承多个接口，使用`,`隔开即可

```
public interface A extends B,C {
    
}
```

如果两个父级接口都有相同的方法声明，对于子接口来讲不影响。因为实现子接口的类会重写方法，无论以哪个接口引用调用的话都可以找到这个方法。

如果一个父级接口有默认方法，另一个父级接口和这个方法一致（不论是否有默认实现），需要子类接口必须重写这个方法，可以在方法中使用`接口名.super`的方式指定其中一个父接口的方法的默认实现

## 继承父类和实现接口的组合

一个类可以继承一个父类，实现多个接口

```
public class A extends B implements C,D {
    
}
```

接口的成员都是静态的常量，因此不会出现变量的冲突。但是可能会出现方法父类和接口的方法冲突。对于接口之间的方法冲突，直接重写接口的方法。对于父类和接口之间的方法冲突，父类优先，接口定义的默认方法会被忽略。

# 接口和抽象类

接口和抽象类很像，他们具有如下特征

- 接口和抽象类都不能被实例化，他们都位于继承树的顶端，用于被其他类实现和集成
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都需要实现这些抽象方法

接口和抽象类的差异体现在二者的设计目的上。

接口作为一个模块和另一个模块的交互窗口，体现的是一种规范。对于接口的设计者而言，接口规定了实现着必须向外提供哪些服务（方法）。对于接口的调用者而言，接口规定了调用者可以使用哪些服务（方法），以及如何使用这些服务（传入具体数据类型的参数，接收具体数据类型的返回值）。当一个程序中使用接口的时候，接口是多个模块间耦合的标准，当多个应用之间使用接口时，接口时多个程序之间的通信标准。接口类似于整个系统的总纲，是统一的标准。因此一个系统的接口不应该经常改变，一旦改变，对整个系统甚至是其他系统的影响是辐射式的，导致系统中大部分类都需要改写。接口是用来约束调用双方的

抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是模板式的设计，子类在约定好的模板基础上进行各自的扩展，是用来约束子类的。

差异点

- 接口里面包含抽象方法和默认方法，抽象类里面包含抽象方法和普通方法
- 接口里只能定义常量属性，抽象类里可以定义任意属性，常量、私有、静态
- 接口没有构造方法，抽象类里可以提供构造方法指导子类初始化抽象类提供的属性
- 一个类可以实现多个接口，但只能继承一个类包括抽象类